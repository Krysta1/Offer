### 归并排序
#### 题目描述
给定你一个长度为n的整数数列。

请你使用归并排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

输入格式
输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。

输出格式
输出共一行，包含 n 个整数，表示排好序的数列。

数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5

#### 解题思路
归并排序是稳定的

将快排迅速改为稳定的做法，对每个元素和下标的pair进行排序，使得每个元素都不同了。<a[i], i>

归并排序也是分治的思想。

- 找分界点  mid = (l+r) / 2
- 递归处理  left right
- 归并操作  合二为一

双指针一次将两个列表中的较小者添加到新的列表中，直到一个走到最后，把剩下的复制到。

刷题效率提升：

- 能够理解模板的思想，并能够寻思默写出来，这是提高最快的方式。
- 找一个模板题来练手，检验一下效果。
- 重置代码，重复写3-5次。

#### 代码

    #include <iostream>
    
    using namespace std;
    
    const int N = 1000010;
    int n;
    int q[N], tmp[N];
    
    void mergeSort(int q[], int l, int r){
        // 如果区间只有一个或者没有元素，直接返回。
        if (l >= r) return;
        
        // 确定分界点，直接使用mid
        int mid = l + r >> 1;
        
        // 左右两个区间进行递归
        mergeSort(q, l , mid);
        mergeSort(q, mid + 1, r);
        
        // 归并操作将两个列表合二为一
        int i = l, j = mid + 1, k = 0;
        while (i <= mid && j <= r){
            if (q[i] < q[j]) tmp[k ++] = q[i ++];
            else tmp[k ++] = q[j ++];
        }
        
        // 将两个列表中剩余的部分复制到tmp
        while (i <= mid) tmp[k ++] = q[i ++];
        while (j <= r) tmp[k ++] = q[j ++];
        
        // tmp复制回q
        for (int i = l, j = 0; i <= r; i ++, j ++){
            q[i] = tmp[j];
        }
    }
    
    int main(){
        scanf("%d", &n);
        for (int i = 0; i < n; i ++){
            scanf("%d", &q[i]);
        }
        mergeSort(q, 0, n - 1);
        for (int i = 0; i < n; i ++){
            printf("%d ", q[i]);
        }
    }

### 逆序对的数量
#### 题目描述

#### 解题思路

#### 代码