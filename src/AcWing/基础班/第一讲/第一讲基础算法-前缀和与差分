### 前缀和

#### 题目描述
输入一个长度为n的整数序列。

接下来再输入m个询问，每个询问输入一对l, r。

对于每个询问，输出原序列中从第l个数到第r个数的和。

输入格式
第一行包含两个整数n和m。

第二行包含n个整数，表示整数数列。

接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。

输出格式
共m行，每行输出一个询问的结果。

数据范围
1≤l≤r≤n,
1≤n,m≤100000,
−1000≤数列中元素的值≤1000
输入样例：
5 3
2 1 3 6 4
1 2
1 3
2 4
输出样例：
3
6
10

#### 解题思路
前缀和的概念：对于一个数列 a1,a2,a3,a4...an

前缀和Si = a1+a2+a3+a4+...+ai

一定要从a1开始

- 如何求前缀和si  直接使用for循环 si = si-1 + ai
- 前缀和的作用，能够快速求出原数组中一段数的和。比如求a[l,r] 使用前缀和 就是Sr - Sl-1

二维的前缀和：计算一个矩阵左上角所有元素的和。可以用来快速计算矩阵中一个区域的和。
S[i, j] = 第i行j列格子左上部分所有元素的和
S[i, j] = S[i-1, j] + S[i, j-1] - S[i-1, j-1] + a[i, j]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

#### 代码
    #include <iostream>
    
    using namespace std;
    
    const int N = 100010;
    int m, n;
    int a[N], s[N];
    
    int main(){
        scanf("%d%d", &m, &n);
        
        for (int i = 1; i <= m; i ++) scanf("%d", &a[i]);
        
        for (int i = 1; i <= m; i ++) s[i] = s[i - 1] + a[i];
        
        while (n --){
            int l, r;
            scanf("%d%d", &l, &r);
            
            printf("%d\n", s[r] - s[l - 1]);
        }
    }


### 差分

#### 题目描述
输入一个长度为n的整数序列。

接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。

请你输出进行完所有操作后的序列。

输入格式
第一行包含两个整数n和m。

第二行包含n个整数，表示整数序列。

接下来m行，每行包含三个整数l，r，c，表示一个操作。

输出格式
共一行，包含n个整数，表示最终序列。

数据范围
1≤n,m≤100000,
1≤l≤r≤n,
−1000≤c≤1000,
−1000≤整数序列中元素的值≤1000
输入样例：
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
输出样例：
3 4 5 3 4 2

#### 解题思路
前缀和 和 差分是逆运算。b数组是a数据的差分，a是b的前缀和

差分：给定一个数组，a[1...n]，构造一个数组b[1...n]使得 a[i] = b[1]+b[2]+...+b[i]

构造方式就是：b[i] = a[i] - a[i-1]

用b求a，在On时间复杂度完成。

用处：a在[l, r]范围所有的数+c (a[l]+c, ..., a[r]+c

可以在b[l]+c，这样a[l]一直到a[n]都会加上c，这时候再b[r+1]的位置再加一个补丁，b[r+1]-c，使得r+1之后到n不会+c

二维差分：对于一个矩阵a[i, j]，构造一个b[i, j]，不需要考虑如何构造，只要记得如何插入就可以了。对一个区域加上同一个数值。

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：

S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c

#### 代码
    